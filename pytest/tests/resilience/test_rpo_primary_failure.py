"""
Teste de RPO - Falha do N√≥ Prim√°rio

Verifica se h√° perda de dados ap√≥s failover.

VERS√ÉO ASS√çNCRONA:
- Observa√ß√£o em tempo real de todos os n√≥s
- Detec√ß√£o precisa de eventos de failover
- Verifica√ß√£o confi√°vel de perda de dados
- SLA: RPO ‚âà 0 (replica√ß√£o s√≠ncrona na mesma regi√£o)
"""
import pytest
import asyncio
from src.core.docker_manager import DockerManager
from src.core.config import config


@pytest.mark.rpo
@pytest.mark.resilience
class TestRPOPrimaryFailure:
    
    @pytest.mark.asyncio
    async def test_primary_failure_data_loss(
        self,
        rpo_collector,
        rpo_writer,
        cluster_healthy,
        get_primary_node,
        pgpool_manager
    ):
        """
        Teste de Resili√™ncia (RPO)
        
        Procedimento (ASS√çNCRONO):
        1. Inicia observa√ß√£o de TODOS os n√≥s do cluster
        2. Cria tabela de teste
        3. Escreve transa√ß√µes no prim√°rio
        4. Simula falha do prim√°rio
        5. Aguarda elei√ß√£o de novo prim√°rio
        6. Verifica se todas as transa√ß√µes foram recuperadas
        
        SLA: RPO ‚âà 0 (mesmo em replica√ß√£o ass√≠ncrona, mesma regi√£o)
        
        IMPORTANTE - Entendendo RPO em Replica√ß√£o ASS√çNCRONA:
        
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ REPLICA√á√ÉO ASS√çNCRONA (synchronous_commit = off)        ‚îÇ
        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
        ‚îÇ 1. Cliente: INSERT                                      ‚îÇ
        ‚îÇ 2. Prim√°rio: escreve WAL                               ‚îÇ
        ‚îÇ 3. Prim√°rio: retorna OK IMEDIATAMENTE                  ‚îÇ
        ‚îÇ 4. Standby: recebe WAL posteriormente                  ‚îÇ
        ‚îÇ                                                         ‚îÇ
        ‚îÇ ‚Üí Transa√ß√£o confirmada ‚â† replicada ainda               ‚îÇ
        ‚îÇ ‚Üí JANELA DE RISCO: perda de dados poss√≠vel             ‚îÇ
        ‚îÇ ‚Üí RPO > 0 poss√≠vel (depende da lat√™ncia)               ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        
        AMBIENTE √öNICO (Docker Localhost):
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ Lat√™ncia ultra-baixa: ~0.1-0.5ms                        ‚îÇ
        ‚îÇ Replica√ß√£o "instant√¢nea" mesmo sendo async             ‚îÇ
        ‚îÇ Tempo de teste (5s) >> tempo de replica√ß√£o (~100ms)   ‚îÇ
        ‚îÇ                                                         ‚îÇ
        ‚îÇ ‚Üí RESULTADO: RPO = 0 esperado                          ‚îÇ
        ‚îÇ ‚Üí Mesmo sem sync, dados s√£o protegidos                 ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        
        Este teste VALIDA que:
        1. Replica√ß√£o ass√≠ncrona funciona corretamente
        2. Lat√™ncia baixa protege contra perda de dados
        3. Standby recebe WAL rapidamente
        
        Em produ√ß√£o (multi-regi√£o):
        - Lat√™ncia: 50-200ms+
        - RPO > 0 poss√≠vel
        - Considerar replica√ß√£o s√≠ncrona para dados cr√≠ticos
        
        Observa√ß√µes:
        - Sem sleeps arbitr√°rios
        - Detec√ß√£o real de eventos via API Patroni
        - Verifica√ß√£o precisa de transa√ß√µes
        """
        docker = DockerManager()
        
        print("\n" + "="*70)
        print("TESTE RPO - FALHA COMPLETA DO N√ì PRIM√ÅRIO (ASYNC)")
        print("="*70)
        
        # 0. Inicia observa√ß√£o ass√≠ncrona
        print("\n[0/7] üîç Iniciando observa√ß√£o do cluster...")
        await rpo_collector.start_observation()
        print("‚úì Cluster sob observa√ß√£o (polling: 100ms)")
        
        # Aguarda estabiliza√ß√£o
        await asyncio.sleep(0.3)
        
        # 1. Setup - Cria tabela de teste
        print("\n[1/7] üìã Criando tabela de teste...")
        success = rpo_collector.setup_test_table()
        assert success, "Falha ao criar tabela de teste"
        print("‚úì Tabela criada")
        
        # 2. Identifica prim√°rio
        print("\n[2/7] üéØ Identificando prim√°rio...")
        initial_primary = get_primary_node()
        assert initial_primary, "Prim√°rio n√£o identificado"
        print(f"‚úì Prim√°rio: {initial_primary}")
        
        metrics = rpo_collector.start_measurement(
            "primary_failure_rpo",
            initial_primary
        )
        
        # 3. Escreve transa√ß√µes de teste (ASS√çNCRONO - injeta falha NO MEIO)
        print("\n[3/7] ‚úçÔ∏è  Iniciando escrita cont√≠nua de transa√ß√µes...")
        print("  ‚ÑπÔ∏è  Nota: Em replica√ß√£o ASS√çNCRONA, h√° janela de risco entre commit e replica√ß√£o")

        num_transactions = 1000  # Volume maior para aumentar chance de capturar lag

        async def _write_transactions_continuously():
            """Escreve transa√ß√µes em background"""
            count = 0
            for i in range(num_transactions):
                try:
                    tx_id = rpo_collector.write_transaction(f"test_data_{i}")
                    if tx_id:
                        count += 1
                except Exception as e:
                    # Esperado: conex√£o pode falhar quando prim√°rio cai
                    print(f"    ‚ö†Ô∏è  TX {i} falhou: {type(e).__name__}")
                    break
                # Delay muito pequeno para simular carga cont√≠nua
                await asyncio.sleep(0.01)  # 10ms entre transa√ß√µes
            return count
        
        # Inicia escrita em background
        print(f" ‚úçÔ∏è  Iniciando escrita de {num_transactions} transa√ß√µes em background...")
        write_task = asyncio.create_task(_write_transactions_continuously())
        
        # Aguarda que metade das transa√ß√µes sejam escritas
        # (tempo estimado: 1000 tx * 10ms = 10s para todas, ent√£o 5s para metade)
        await asyncio.sleep(5.0)

        # Captura quantas foram escritas at√© agora
        pre_failure_tx = rpo_collector.metrics.last_transaction_id_written or 0
        print(f"  ‚è±Ô∏è  Transa√ß√µes escritas at√© agora: {pre_failure_tx}")
        print(f"  üí• Injetando falha AGORA (com escritas ainda em andamento)...")
        
        # 4. Injeta falha NO MEIO da escrita
        print(f"\n[4/7] üí• KILL {initial_primary} (escritas continuam em background)...")
        rpo_collector.mark_failure_occurred()
        
        success = docker.kill_container(initial_primary,signal="SIGKILL")
        assert success, "Falha ao parar container"
        print(f"‚úì Container {initial_primary} morto instantaneamente (SIGKILL)")
        
        # Aguarda task de escrita terminar ou falhar
        print(f"  ‚è±Ô∏è  Aguardando task de escrita finalizar/falhar...")
        try:
            transactions_attempted = await asyncio.wait_for(write_task, timeout=10)
            print(f"  ‚úì Task completou: {transactions_attempted} transa√ß√µes tentadas")
        except asyncio.TimeoutError:
            print(f"  ‚ö†Ô∏è  Task timeout (esperado se conex√£o travou)")
            write_task.cancel()
            try:
                await write_task
            except asyncio.CancelledError:
                pass
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Task falhou: {type(e).__name__} (esperado)")
        
        last_tx_id = rpo_collector.metrics.last_transaction_id_written or 0
        print(f"  üìä √öltima TX ID CONFIRMADA antes da falha: {last_tx_id}")
        print(f"  üéØ Transa√ß√µes 'em voo': ~{num_transactions - last_tx_id}")
        
        # 5. Aguarda novo prim√°rio
        print(f"\n[5/7] üó≥Ô∏è  Observando elei√ß√£o de novo prim√°rio...")
        new_primary = await rpo_collector.wait_for_new_primary(
            timeout=60,
            old_primary=initial_primary
        )
        assert new_primary, "Timeout: novo prim√°rio N√ÉO foi eleito!"
        assert new_primary != initial_primary, "Prim√°rio n√£o mudou!"
        
        # 6. Verifica dados recuperados
        print("\n[6/7] üîç Verificando dados recuperados...")
        recovered_count = await rpo_collector.verify_data_after_recovery()
        
        print(f"  Transa√ß√µes escritas:    {last_tx_id}")
        print(f"  Transa√ß√µes recuperadas: {recovered_count}")
        
        # 7. Finaliza medi√ß√£o
        print(f"\n[7/7] üìä Finalizando medi√ß√£o...")
        rpo_collector.finalize_metrics()
        
        # Para observa√ß√£o
        await rpo_collector.stop_observation()
        
        # Obt√©m m√©tricas
        metrics = rpo_collector.get_metrics()
        assert metrics, "M√©tricas n√£o foram coletadas"
        
        # Salva resultados
        rpo_writer.write(metrics)
        
        # Exibe resultados
        self._print_rpo_metrics(metrics, num_transactions)
        
        # Exibe eventos detectados
        print(rpo_collector.get_events_summary())
        
        # Valida SLA (RPO ‚âà 0)
        self._validate_sla_rpo(metrics)
        
        # Cleanup: reinicia o container e re-anexa o n√≥ ao PgPool via PCP
        print(f"\n[Cleanup] üîÑ Reiniciando {initial_primary}...")
        docker.start_container(initial_primary)

        # Aguarda container subir
        await asyncio.sleep(2)

        # Re-anexa n√≥s ao PgPool
        pgpool_manager.attach_down_nodes()

        # Remove tabela de teste
        rpo_collector.drop_test_table()
        
        # Aguarda estabiliza√ß√£o (pode usar um pouco de tempo aqui, n√£o √© medido)
        await asyncio.sleep(5)
        print("‚úì Cleanup conclu√≠do")
    
    def _print_rpo_metrics(self, metrics, expected_count):
        """Exibe m√©tricas formatadas com detalhamento"""
        print("\n" + "="*70)
        print("M√âTRICAS DE RPO (MEDI√á√ÉO ASS√çNCRONA)")
        print("="*70)
        print(f"Test Case:         {metrics.test_case}")
        print(f"N√≥ que falhou:     {metrics.failed_node}")
        print(f"Novo prim√°rio:     {metrics.new_primary_node}")
        print("-"*70)
        print("DADOS DE TRANSA√á√ïES:")
        print(f"  TXs escritas:          {metrics.last_transaction_id_written}")
        print(f"  TXs recuperadas:       {metrics.last_transaction_id_recovered}")
        print(f"  TXs perdidas:          {metrics.transactions_lost}")
        print(f"  Houve perda:           {'SIM ‚ö†Ô∏è' if metrics.data_loss_occurred else 'N√ÉO ‚úÖ'}")
        print("-"*70)
        if metrics.replication_lag_bytes is not None:
            print(f"Lag de replica√ß√£o:     {metrics.replication_lag_bytes} bytes")
        if metrics.rpo_seconds is not None:
            print(f"RPO (segundos):        {metrics.rpo_seconds:.3f}s")
        print("="*70)

    
    def _validate_sla_rpo(self, metrics):
        """Valida SLA de RPO e exibe resultados"""
        
        print(f"\n{'='*70}")
        print("VALIDA√á√ÉO DE SLA - REPLICA√á√ÉO ASS√çNCRONA")
        print("="*70)
 
        lost = metrics.transactions_lost or 0
        written = metrics.last_transaction_id_written or 1
        loss_percent = (lost / written * 100) if written > 0 else 0
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # DEFINI√á√ÉO DE SLAs POR AMBIENTE
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        # Ambiente √∫nico (Docker localhost)
        sla_single_env = {
            'name': '√önico (Docker Localhost)',
            'latency': '0.1-0.5ms',
            'target_rpo_percent': 0.0,   # 0% esperado
            'max_rpo_percent': 1.0,      # at√© 1% aceit√°vel
            'description': 'Lat√™ncia ultra-baixa, replica√ß√£o "instant√¢nea"'
        }
        
        # Produ√ß√£o - Mesma regi√£o
        sla_same_region = {
            'name': 'Produ√ß√£o - Mesma Regi√£o',
            'latency': '1-5ms',
            'target_rpo_percent': 0.0,   # 0% ideal
            'max_rpo_percent': 2.0,      # at√© 2% aceit√°vel
            'description': 'Lat√™ncia baixa, perda m√≠nima'
        }
        
        # Produ√ß√£o - Multi-regi√£o (mesmo continente)
        sla_multi_region = {
            'name': 'Produ√ß√£o - Multi-Regi√£o',
            'latency': '20-50ms',
            'target_rpo_percent': 2.0,   # 2% esperado
            'max_rpo_percent': 5.0,      # at√© 5% aceit√°vel
            'description': 'Lat√™ncia m√©dia, perda moderada'
        }
        
        # Produ√ß√£o - Inter-continental
        sla_intercontinental = {
            'name': 'Produ√ß√£o - Inter-Continental',
            'latency': '100-300ms',
            'target_rpo_percent': 5.0,   # 5% esperado
            'max_rpo_percent': 10.0,     # at√© 10% aceit√°vel
            'description': 'Lat√™ncia alta, considerar replica√ß√£o s√≠ncrona'
        }
        
        # Seleciona SLA do ambiente atual (√∫nico)
        current_sla = sla_single_env
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # VALIDA√á√ÉO AMBIENTE ATUAL
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        print(f"Ambiente atual:    {current_sla['name']}")
        print(f"Lat√™ncia t√≠pica:   {current_sla['latency']}")
        print(f"Descri√ß√£o:         {current_sla['description']}")
        print("-"*70)
        
        # Valida√ß√£o
        target_met = loss_percent <= current_sla['target_rpo_percent']
        acceptable = loss_percent <= current_sla['max_rpo_percent']
        
        print(f"Target RPO:        ‚â§ {current_sla['target_rpo_percent']:.1f}% (ideal)")
        print(f"M√°ximo aceit√°vel:  ‚â§ {current_sla['max_rpo_percent']:.1f}%")
        print(f"RPO medido:        {loss_percent:.2f}% ({lost} de {written} transa√ß√µes)")
        
        if target_met:
            status = "‚úÖ EXCELENTE"
        elif acceptable:
            status = "‚úÖ PASSOU"
        else:
            status = "‚ö†Ô∏è  FALHOU"
        
        print(f"Status:            {status}")
        print("="*70)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # COMPARA√á√ÉO COM OUTROS AMBIENTES (REFER√äNCIA)
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        print("\nüìä COMPARA√á√ÉO: RPO ESPERADO EM DIFERENTES AMBIENTES")
        print("="*70)
        
        scenarios = [sla_single_env, sla_same_region, sla_multi_region, sla_intercontinental]
        
        for scenario in scenarios:
            is_current = (scenario == current_sla)
            marker = "‚Üí VOC√ä EST√Å AQUI" if is_current else ""
            
            print(f"\n{scenario['name']} {marker}")
            print(f"  Lat√™ncia:         {scenario['latency']}")
            print(f"  RPO esperado:     {scenario['target_rpo_percent']:.1f}% - {scenario['max_rpo_percent']:.1f}%")
            print(f"  Descri√ß√£o:        {scenario['description']}")
            
            if is_current:
                print(f"  Seu resultado:    {loss_percent:.2f}% {'‚úÖ' if acceptable else '‚ö†Ô∏è'}")
        
        print("="*70)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # AN√ÅLISE DETALHADA DO RESULTADO
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        print("\nüìà AN√ÅLISE DO RESULTADO")
        print("="*70)
        
        if lost == 0:
            print("‚úÖ ZERO PERDA DE DADOS")
            print("")
            print("Significado:")
            print("  ‚Ä¢ Todas as transa√ß√µes foram replicadas antes da falha")
            print("  ‚Ä¢ Replica√ß√£o ass√≠ncrona suficientemente r√°pida")
            print("  ‚Ä¢ Lat√™ncia n√£o √© fator limitante neste ambiente")
            print("  ‚Ä¢ Standby estava sincronizado")
            print("")
            print("Conclus√£o:")
            print("  ‚úì Sistema resiliente e confi√°vel")
            print("  ‚úì Replica√ß√£o ass√≠ncrona adequada para este ambiente")
            print("  ‚úì Sem necessidade de replica√ß√£o s√≠ncrona")
            
        elif acceptable:
            print(f"‚úÖ PERDA M√çNIMA ACEIT√ÅVEL ({lost} transa√ß√µes)")
            print("")
            print("Significado:")
            print(f"  ‚Ä¢ {loss_percent:.2f}% de perda est√° dentro do esperado")
            print("  ‚Ä¢ Janela de risco entre commit e replica√ß√£o")
            print("  ‚Ä¢ Comportamento normal em replica√ß√£o ass√≠ncrona")
            print("")
            print("Conclus√£o:")
            print("  ‚úì Sistema funcionando conforme especifica√ß√£o")
            print("  ‚úì RPO aceit√°vel para este tipo de replica√ß√£o")
            
        else:
            print(f"‚ö†Ô∏è  PERDA ACIMA DO ESPERADO ({lost} transa√ß√µes)")
            print("")
            print("Poss√≠veis causas:")
            print("  ‚Ä¢ Lag de replica√ß√£o alto")
            print("  ‚Ä¢ Standby sobrecarregado")
            print("  ‚Ä¢ Problemas de rede")
            print("  ‚Ä¢ WAL sender/receiver lentos")
            print("")
            print("Recomenda√ß√µes:")
            print("  ‚Üí Investigar logs do PostgreSQL")
            print("  ‚Üí Verificar m√©tricas de replica√ß√£o")
            print("  ‚Üí Considerar tuning de WAL")
            print("  ‚Üí Avaliar upgrade de hardware")
        
        print("="*70)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # RESULTADO FINAL
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        if target_met:
            print(f"\nüéâ RESULTADO: RPO = {lost} transa√ß√µes ({loss_percent:.2f}%)")
            print(f"   Objetivo atingido! Perda {'zero' if lost == 0 else 'm√≠nima'}.")
        elif acceptable:
            print(f"\n‚úÖ RESULTADO: RPO = {lost} transa√ß√µes ({loss_percent:.2f}%)")
            print(f"   Dentro do aceit√°vel para ambiente {current_sla['name']}.")
        else:
            print(f"\n‚ö†Ô∏è  RESULTADO: RPO = {lost} transa√ß√µes ({loss_percent:.2f}%)")
            print(f"   Acima do esperado. Investiga√ß√£o necess√°ria.")

