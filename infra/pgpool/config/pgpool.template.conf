# =============================================================================
# Arquivo de Template para pgpool.conf (Revisado e Aprimorado)
# Adaptado para um ambiente dinâmico.
# =============================================================================

# --- CONFIGURAÇÕES DE CONEXÃO E PCP ---
listen_addresses = '*'
port = 5432

pcp_listen_addresses = '*'
pcp_port = 9898

socket_dir = '/tmp'
pcp_socket_dir = '/tmp'

# --- CONFIGURAÇÃO DOS BACKENDS (SERÁ PREENCHIDA DINAMICAMENTE) ---
##BACKEND_NODES_CONFIG##

# --- MODOS DE OPERAÇÃO E BALANCEAMENTO DE CARGA ---
backend_clustering_mode = 'streaming_replication'
load_balance_mode = on
master_slave_mode = on
master_slave_sub_mode = 'stream'
replication_mode = off

# --- POOLING DE CONEXÃO E PERFORMANCE (TUNING) ---
# Número de processos filhos pré-forkados. Um valor maior permite mais conexões simultâneas.
# Este valor será substituído pela variável de ambiente ${PGPOOL_NUM_INIT_CHILDREN}.
num_init_children = 32
# Máximo de conexões simultâneas permitidas.
# Este valor será substituído pela variável de ambiente ${PGPOOL_MAX_POOL}.
max_pool = 4
connection_cache = on
child_life_time = 300
client_idle_limit = 3600
serialize_accept = off
allow_sql_comments = on
ignore_leading_white_space = on

# --- CHECAGEM DE REPLICAÇÃO (STREAMING REPLICATION CHECK) ---
sr_check_period = 10
sr_check_user = 'replicator'     # Usuário com permissões de replicação
sr_check_password = ''           # A senha virá do .pgpass
sr_check_database = 'postgres'

# --- CHECAGEM DE SAÚDE (HEALTH CHECK) - COM TUNING ---
health_check_period = 5
health_check_timeout = 10
health_check_max_retries = 3     # Aumentado para maior resiliência
health_check_retry_delay = 2     # Adicionado para evitar sobrecarga em caso de falha
health_check_user = 'healthchecker' # Usuário dedicado com privilégios mínimos
health_check_password = ''       # A senha virá do .pgpass
health_check_database = 'postgres'

# --- FAILOVER E FAILBACK (AUTOMATIZADO VIA HOOKS) ---
failover_on_backend_error = on
fail_over_on_backend_shutdown = on
failover_command = '/usr/local/bin/scripts/hooks/failover.sh %d %H %p %D %m %M %P %r %R'
follow_primary_command = '/usr/local/bin/scripts/hooks/follow_primary.sh %d %H %p %D %m %M %P %r %R'
failback_command = '' # O failback deve ser um processo manual e controlado

# --- LOGGING (CONFIGURADO PARA CONTAINERS) ---
logging_collector = on
log_destination = 'stderr'       # Melhor prática para Docker
log_connections = off            # Desligado para não poluir os logs
log_statement = off              # Desligado para não poluir os logs
log_hostname = on
client_min_messages = warning
log_min_messages = warning