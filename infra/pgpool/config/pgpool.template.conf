# =============================================================================
# Arquivo de Template para pgpool.conf (Revisado e Aprimorado)
# Adaptado para um ambiente dinâmico com Patroni
# Autor: Eduardo Richard
# =============================================================================

# --- CONFIGURAÇÕES DE CONEXÃO E PCP ---
listen_addresses = '*'
port = 5432
# Tamanho da fila de conexões TCP pendentes (crítico para burst de 100 clientes)
# Default é 128, aumentando para 1024 para evitar connection refused
listen_backlog = 1024
# Número de conexões reservadas para super usuários
reserved_connections = 5

# --- CONFIGURAÇÃO SSL ---
ssl = off

# --- PCP (Pgpool Control Protocol) ---
pcp_listen_addresses = '*'
pcp_port = 9898

# Aponta os arquivos de runtime para o diretório efêmero padrão do Linux.
# O entrypoint.sh garante que este diretório seja criado e permissionado.
pid_file_name = '/var/run/pgpool/pgpool.pid'
socket_dir = '/var/run/pgpool'
pcp_socket_dir = '/var/run/pgpool'

# --- CONFIGURAÇÃO DOS BACKENDS (SERÁ PREENCHIDA DINAMICAMENTE) ---
##BACKEND_NODES_CONFIG##

# --- MODOS DE OPERAÇÃO E BALANCEAMENTO DE CARGA ---
backend_clustering_mode = 'streaming_replication'
load_balance_mode = on
master_slave_mode = on
master_slave_sub_mode = 'stream'
replication_mode = off
enable_pool_hba = on
pool_hba_conf_file = '/opt/pgpool/etc/pool_hba.conf'

# --- POOLING DE CONEXÃO E PERFORMANCE (TUNING) ---
# Número de processos filhos pré-forkados. Um valor maior permite mais conexões simultâneas.
num_init_children = ${PGPOOL_NUM_INIT_CHILDREN:-32}
# Máximo de conexões simultâneas permitidas.
max_pool = ${PGPOOL_MAX_POOL:-100}
connection_cache = on
# Tempo de vida de um processo filho (0 = infinito, recomendado para testes)
child_life_time = 0
# Timeout de cliente ocioso (1 hora)
client_idle_limit = 3600
# Limite de conexões por processo filho (0 = sem limite)
child_max_connections = 0
# Aceita conexões mesmo quando todos os processos estão ocupados (enfileira)
serialize_accept = on
# Número de clientes que podem esperar na fila quando todos os processos estão ocupados
listen_backlog_multiplier = 2
# Timeouts mais tolerantes para burst de 100 conexões
connection_life_time = 0
authentication_timeout = 60
allow_sql_comments = on
ignore_leading_white_space = on

# --- CHECAGEM DE REPLICAÇÃO (STREAMING REPLICATION CHECK) ---
# Aumentado para reduzir overhead durante alta carga
sr_check_period = 30
sr_check_user = replicator
sr_check_password = ''
sr_check_database = postgres

# --- CHECAGEM DE SAÚDE (HEALTH CHECK) - AJUSTADO PARA ALTA CARGA ---
# Período entre health checks (aumentado para reduzir overhead)
health_check_period = 60
# Timeout para resposta do backend (aumentado para evitar falsos positivos)
health_check_timeout = 30
# Máximo de tentativas antes de marcar backend como down
health_check_max_retries = 10
# Delay entre retentativas (aumentado)
health_check_retry_delay = 10
health_check_user = healthchecker
health_check_password = ''
health_check_database = postgres

pool_passwd = '/opt/pgpool/pool_passwd'

# --- FAILOVER E FAILBACK (AUTOMATIZADO VIA HOOKS) ---
failover_on_backend_error = on
fail_over_on_backend_shutdown = on
failover_command = '/opt/pgpool/bin/scripts/hooks/failover.sh %d %H %p %D %m %M %P %r %R'
follow_primary_command = '/opt/pgpool/bin/scripts/hooks/follow_primary.sh %d %H %p %D %m %M %P %r %R'
failback_command = ''

# --- LOGGING (CONFIGURADO PARA CONTAINERS) ---
logging_collector = off
log_destination = 'stderr'
log_connections = off
log_statement = off
log_hostname = on
client_min_messages = warning
log_min_messages = warning
log_error_verbosity = verbose
